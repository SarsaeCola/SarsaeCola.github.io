<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>最短路径算法 | SarsaeCola</title><meta name="description" content="转载自wlu 最短路径问题在交通地图上，两地点之间的路径通常标有长度，我们可以用加权有向来描述地图上的交通网。加权有向图中每条路径都有一个路径权值，大小为该路径上所有边的权值之和。本节将重点讨论顶点之间最短路径问题。在实际问题中，路径权值还可以表示其它类型的开销，例如两地之间行程所需要的时间；两任务切换所需代价等。 本节讨论的最短路径具有方向性，问题用图的术语描述为：给定一个起始顶点s和一个结束顶"><meta name="keywords" content="图论"><meta name="author" content="sarsae"><meta name="copyright" content="sarsae"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/09/23/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="最短路径算法"><meta property="og:url" content="http://yoursite.com/2020/09/23/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="SarsaeCola"><meta property="og:description" content="转载自wlu 最短路径问题在交通地图上，两地点之间的路径通常标有长度，我们可以用加权有向来描述地图上的交通网。加权有向图中每条路径都有一个路径权值，大小为该路径上所有边的权值之和。本节将重点讨论顶点之间最短路径问题。在实际问题中，路径权值还可以表示其它类型的开销，例如两地之间行程所需要的时间；两任务切换所需代价等。 本节讨论的最短路径具有方向性，问题用图的术语描述为：给定一个起始顶点s和一个结束顶"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-09-23T12:23:50.000Z"><meta property="article:modified_time" content="2020-09-23T13:30:15.902Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-09-23 21:30:15'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">48</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#最短路径问题"><span class="toc-number">1.</span> <span class="toc-text">最短路径问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra算法"><span class="toc-number">2.</span> <span class="toc-text">Dijkstra算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BellmanFord算法"><span class="toc-number">3.</span> <span class="toc-text">BellmanFord算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Floyd算法"><span class="toc-number">4.</span> <span class="toc-text">Floyd算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JohnSon算法"><span class="toc-number">5.</span> <span class="toc-text">JohnSon算法</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SarsaeCola</a></span><span class="pull-right menus"><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">最短路径算法</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-23T12:23:50.000Z" title="发表于 2020-09-23 20:23:50">2020-09-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-23T13:30:15.902Z" title="更新于 2020-09-23 21:30:15">2020-09-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>转载自<a href="https://www.cnblogs.com/luweiseu/archive/2012/07/14/2591533.html" target="_blank" rel="noopener">wlu</a></p>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><p>在交通地图上，两地点之间的路径通常标有长度，我们可以用加权有向来描述地图上的交通网。加权有向图中每条路径都有一个路径权值，大小为该路径上所有边的权值之和。本节将重点讨论顶点之间最短路径问题。在实际问题中，路径权值还可以表示其它类型的开销，例如两地之间行程所需要的时间；两任务切换所需代价等。</p>
<p>本节讨论的最短路径具有方向性，问题用图的术语描述为：给定一个起始顶点s和一个结束顶点t，在图中找出从s到t的一条最短路径。称s为路径源点，t为路径汇点。</p>
<p>最短路径问题可以进一步分为单源最短路径和全源最短路径。</p>
<ul>
<li><p>单源最短路径定义为，给定起始顶点s，找出从s到图中其它各顶点的最短路径。求解单源最短路径的算法主要是Dijkstra算法和Bellman-Ford算法，其中Dijkstra算法主要解决所有边的权为非负的单源最短路径问题，而Bellman-Ford算法可以适用于更一般的问题，图中边的权值可以为负。</p>
</li>
<li><p>全源最短路径定义为，找出连接图中各对顶点的最短路径。求解全源最短路径的算法主要有Floyd算法和Johonson算法，其中Floyd算法可以检测图中的负环并可以解决不包括负环的图中的全源最短路径问题；Johonson算法同样也是解决不包含负环的图的全源最短路径问题，但是其算法效率更高。</p>
</li>
</ul>
<p>1 基本原则<br>最短路径算法具有最短路径的最优子结构性质，也就是两顶点之间的最短路径包括路径上其它顶点的最短路径。具体描述为：对于给定的带权图G=(V, E)，设p=&lt;v1, v2, …,vk&gt;是从v1到vk的最短路径，那么对于任意i和j，1≤i≤j≤k，pij=&lt;vi, vi+1, …, vj&gt;为p中顶点vi到vj的子路径，那么pij是顶点vi到vj的最短路径。</p>
<p>最短路径算法都使用了松弛(relaxation)技术。开始进行一个最短路径算法时，只知道图中边和权值。随着处理逐渐得到各对顶点的最短路径的信息。算法会逐渐更新这些信息，每步都会检查是否可以找到一条路径比当前给定路径更短。这一过程通常称为“松弛”。</p>
<p>如图为单元最短路径算法的松弛操作。问题为求求解顶点s到图中各顶点之间的最短路径，用d[i]表示顶点s到顶点i的最短路径的长度。对权值为1的边(v, w)进行松弛，若当前到顶点v和w的最短路径的长度分别6和8，如图(a)，则此时d[w]&lt;d[v]+ ω(v, w)，所以对d[w]的值需要减小，并且s到顶点w的最短路径为顶点s到v的最短路径，再经过边(v, w)，如图(b)。</p>
<p>我们用d[i]数组表示顶点s到顶点i的最短路径的长度，用p[i]表示顶点i在最短路径中的父顶点。可以将边松弛过程用一下代码来描述：</p>
<blockquote>
<p>Relax(v, w, ω(v, w))<br>if d[w]&gt;d[v] + ω(v, w){<br>    d[w]=d[v] + ω(v, w);<br>    p[w] = v;<br>}</p>
</blockquote>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>首先，我们需要明确Dijkstra算法的适用范围是权值非负的图，即解决带有非负权值的图中的单源最短路径问题。下面对这一属性做简单分析。</p>
<p>给定顶点s，通过Dijkstra算法得到的最短路径树中，从根s到树中各顶点u的树路径对应着图中从顶点s到顶点u的最短路径。归纳证明如下：</p>
<p>假设当前所得到的子树具有这一属性，向当前子树中添加新的顶点u，满足：从顶点s出发，经过当前SPT中的树路径，并最终到达u。可以通过选择，使得所选择的s到u的路径比所有满足条件的路径都更短。所以增加一个新的顶点将增加到达该顶点的一条最短路径。</p>
<p>如果边的权值可以为负数，那么上述证明过程将不成立，上述证明中已经假设了向当前子树中添加新的边时，路径的长度不会递减。然而在具有负权值的边的图中，这个假设不能满足，因为所遇到的任何边都可能指向子树中的某个顶点，而且这条边可能有一个负权值，从而会使得到达该顶点的路径比树路径更短。</p>
<p>以下是Dijkstra算法的实现，Dijkstra算法和基于优先队列的Dijkstra算法都在SingleSourceShortestPaths类中实现，类中包括存放每个顶点到源点的最近距离D数组和存放各个顶点的在SPT(最短路径树)中的父节点V数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dijkstra 算法寻找图中单源点最短路径</span></span><br><span class="line"><span class="comment"> * 输入为待寻找的图G以及源点s</span></span><br><span class="line"><span class="comment"> * @param s    起始顶点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> nv = G.get_nv();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nv; i++)&#123;</span><br><span class="line">        D[i] = Integer.MAX_VALUE;</span><br><span class="line">        V[i] = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 0 没有添加到树中</span></span><br><span class="line">        G.setMark(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对起点s，父节点为-1，距离为0</span></span><br><span class="line">    V[s] = -<span class="number">1</span>;</span><br><span class="line">    D[s] = <span class="number">0</span>;</span><br><span class="line">    G.setMark(s, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(Edge w = G.firstEdge(s); </span><br><span class="line">            G.isEdge(w); w = G.nextEdge(w))&#123;</span><br><span class="line">        D[G.edge_v2(w)] = G.getEdgeWt(w);</span><br><span class="line">        V[G.edge_v2(w)] = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在其余顶点中找到与当前SPT最近的顶点v，并将</span></span><br><span class="line"><span class="comment">     * 顶点的父节点和顶点v添加到SPT中。其中图的</span></span><br><span class="line"><span class="comment">     * 权值存放在节点v中。</span></span><br><span class="line"><span class="comment">     * 循环迭代，直至所有顶点都遍历一遍.*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">/*获取与当前树距离最近的边，其终点为最近的顶点</span></span><br><span class="line"><span class="comment">         * 起点为最近顶点的父节点 */</span></span><br><span class="line">        Edge E = Utilities.minNextEdge(G, V);</span><br><span class="line">        <span class="comment">//如果边为空，函数返回</span></span><br><span class="line">        <span class="keyword">if</span>(E == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        System.out.println(<span class="string">"ad ("</span> + E.get_v1() + </span><br><span class="line">                           <span class="string">", "</span> + E.get_v2() + </span><br><span class="line">                           <span class="string">"),\t"</span> + G.getEdgeWt(E));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// E的终点v被访问过了</span></span><br><span class="line">        <span class="keyword">int</span> v = E.get_v2();</span><br><span class="line">        G.setMark(v, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新与v相连的所有边的距离（松弛过程）</span></span><br><span class="line">        <span class="keyword">for</span>(Edge w = G.firstEdge(v); </span><br><span class="line">                G.isEdge(w); w = G.nextEdge(w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(D[G.edge_v2(w)] &gt; (D[v] + G.getEdgeWt(w)))&#123;</span><br><span class="line">                <span class="comment">// 更新最短距离</span></span><br><span class="line">                D[G.edge_v2(w)] = D[v] + G.getEdgeWt(w);</span><br><span class="line">                <span class="comment">// 更新父节点</span></span><br><span class="line">                V[G.edge_v2(w)] = v;</span><br><span class="line">                System.out.println(<span class="string">"rx ("</span> + w.get_v1() + </span><br><span class="line">                           <span class="string">", "</span> + w.get_v2() + </span><br><span class="line">                           <span class="string">"),\t"</span> + G.getEdgeWt(w));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据V数组建立最短路径树SPT</span></span><br><span class="line">    spt.addChild(s, s, <span class="keyword">new</span> ElemItem&lt;Double&gt;(D[<span class="number">0</span>]));</span><br><span class="line">    spt.setRoot(s);</span><br><span class="line">    <span class="keyword">int</span> f = -<span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 顶点标记数组，V_idx[i] == 1表示i顶点已经在SPT中，否则不再SPT中</span></span><br><span class="line">    <span class="keyword">int</span>[] V_idx = <span class="keyword">new</span> <span class="keyword">int</span>[V.length];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V_idx.length; i++)V_idx[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 起始顶点s已经在SPT中</span></span><br><span class="line">    V_idx[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        f = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 顶点i不在SPT中，其父顶点V[i]在SPT中，则添加到SPT中</span></span><br><span class="line">            <span class="keyword">if</span>(V_idx[i] == <span class="number">0</span> &amp;&amp; V[i] &gt;= <span class="number">0</span> </span><br><span class="line">            &amp;&amp; V_idx[V[i]] == <span class="number">1</span> &amp;&amp; </span><br><span class="line">            spt.addChild(V[i], i, <span class="keyword">new</span> ElemItem&lt;Double&gt;(D[i])))&#123;</span><br><span class="line">                V_idx[i] = <span class="number">1</span>;</span><br><span class="line">                f = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次都没有添加，结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(f == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法中每次从SPT之外的顶点中选择一个顶点v，对应边的权值最小；然后对这条边进行松弛操作。算法迭代直至图中所有顶点都在SPT中为止。</p>
<p>以图为例，求解图的最短路径树，起始顶点为顶点0。根据算法实现过程，提取图中最短路径数的过程如图(a-c)。<br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-33-42.png"></p>
<p>算法初始化阶段每个顶点到起始顶点s的最短路径长度为∞。首先从起始顶点0开始，寻找相邻顶点1和顶点5，并对其进行松弛操作。此时SPT中根节点为0，两个（未确定）子节点为顶点1和顶点5。其中顶点0着色为灰色（赋值1），只有着色为灰色的顶点确定为SPT中顶点。</p>
<p>由于顶点1和顶点5对应的边可能会在以后的操作中进行松弛操作，所以SPT中这两个顶点是未确定的，顶点着色也未改变。<br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-34-19.png"></p>
<p>选择与当前SPT中顶点0最近的顶点5，首先将顶点5确定为SPT中顶点0的子节点；然后对其相邻顶点进行松弛操作。相邻顶点为顶点1和顶点4，其中顶点4的最短距离需要更新。<br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-34-34.png"></p>
<p>选择与当前SPT中顶点0、顶点5最近的顶点4，首先将顶点4确定为SPT中顶点5的子节点；然后对其相邻顶点进行松弛操作。相邻顶点为顶点2和顶点3，这两个顶点都需要更新最短距离。</p>
<p>接下来将先后选择边(5, 1)、(4, 2)和(4, 3)，并进行松弛操作。最终得到的SPT为：<br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-34-51.png"></p>
<h2 id="BellmanFord算法"><a href="#BellmanFord算法" class="headerlink" title="BellmanFord算法"></a>BellmanFord算法</h2><p>Bellman-Ford算法诞生于20世纪50年代，对于不包含负环的图，该算法可以简单有效地求解图的单源最短路径问题。算法的基本思路非常简单：以任意顺序考虑图的边，沿着各条边进行松弛操作，重复操作|V|次(|V|表示图中顶点的个数)。</p>
<p>对有向带权图G = (V, E)，从顶点s起始，利用Bellman-Ford算法求解各顶点最短距离，算法描述如下：</p>
<p>for(i = 0; i &lt; |V|; i++)<br>    for each edge(u, v) ∈  E<br>        RELAX(u, v) </p>
<p>算法对每条边做松弛操作，并且重复|V|次，所以算法可以在于|V|·|E|成正比的时间内解决单源最短路径问题。算法十分简单，但是在实际中并不被采用，对其做简单的改进就可以得到更高效算法。</p>
<p>我们对算法的正确性做简单分析。设每个顶点距离起始顶点s的最短距离存放在数组D中。</p>
<p>我们首先假设以下命题为真：算法在第i遍处理之后，对于所有顶点u，D[u]不大于s到u且包含i条（或更少）边的最短路径的长度。</p>
<p>根据以上命题，经过|V|-1次迭代后，对所给定的顶点u，D[u]为任何从s到u且包含|V|-1条（或更少）边的最短路径的长度的下界。此时算法可以停止迭代，因为包含|V|条边（或更多）的任何路径将必然有一个环，通过去除这个环将可以找到一条包含|V|-1（或更少）边的路径，该路径长度不大于去环前的路径的长度。所以D[u]同时又是从s到u的最短路径的上界，既然D[u]同时是下界和上界，那么必然是最短路径的长度。</p>
<p>下面我们对上述命题做归纳证明。i为0时，命题自然为成立；假设命题对于i成立，那么对于每个给定的顶点u分两种情况： </p>
<p>l 在从s到u包含i+1条（或更少）边的路径中，如果其中最短路径长度为i（或更少），那么D[u]不做调整。</p>
<p>l 否则，有一条从s到u且包含i+1条边的路径，其长度比s到u且包含i（或更少）条边的任何路径都短。该路径必然由s先到达某个顶点w的路径再加上边(w, u)所组成。由归纳假设，D[w]是从s到w的最短距离的上边界，而且第i+1遍处理会对各条边进行检查。</p>
<p>所以算法在第i+1遍处理之后，对于所有顶点u，D[u]不大于s到u且包含i条（或更少）边的最短路径的长度</p>
<p>然而算法每遍处理对于各条边都进行检查将是很大的浪费，因为有大量的边并不会导致有效的松弛。事实上，唯一可能导致调整的边仅为某些特定顶点出发的边：这些顶点的值在上一遍处理中发生了变化。</p>
<p>那么可以对算法进行优化，即每遍处理只对特定顶点出发的边做松弛操作。可以将发生变化的顶点的记录下来，在下一遍处理时对一这些顶点为源点的边做松弛操作。我们使用队列结构来存储这些顶点，以下是算法的实现，算法在MinusWeightGraph类中实现，类中包括存放每个顶点到源点的最近距离D数组和存放各个顶点的在SPT中的父节点V数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bellman-Ford 算法求解给定图的单源最短路径；</span></span><br><span class="line"><span class="comment"> * 图中边的权值可以是负数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s    起始顶点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> nv = G.get_nv();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nv; i++)&#123;</span><br><span class="line">        D[i] = Double.MAX_VALUE;</span><br><span class="line">        V[i] = -<span class="number">2</span>;</span><br><span class="line">        G.setMark(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列Q</span></span><br><span class="line">    LinkQueue Q = <span class="keyword">new</span> LinkQueue();</span><br><span class="line">    <span class="comment">// 起始顶点的距离为0</span></span><br><span class="line">    D[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将起点s和nv添加到队列中</span></span><br><span class="line">    <span class="keyword">int</span> M = Integer.MAX_VALUE;</span><br><span class="line">    Q.enqueue(<span class="keyword">new</span> ElemItem&lt;Integer&gt;(s));</span><br><span class="line">    Q.enqueue(<span class="keyword">new</span> ElemItem&lt;Integer&gt;(M));</span><br><span class="line">    System.out.print(<span class="string">"●"</span>);</span><br><span class="line">    Q.printQueue();</span><br><span class="line">    <span class="comment">// 迭代过程，直到Q为空</span></span><br><span class="line">    <span class="keyword">while</span>(Q.currSize() != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> f  = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v, N = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(M == (v = ((Integer)(Q.dequeue().elem)).intValue()))&#123;</span><br><span class="line">            <span class="keyword">if</span>(N++ &gt; nv)&#123; f = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            Q.enqueue(<span class="keyword">new</span> ElemItem&lt;Integer&gt;(M));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"⊙ "</span>);</span><br><span class="line">        Q.printQueue();</span><br><span class="line">        <span class="keyword">if</span>(f == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 对v的所有相连的边e</span></span><br><span class="line">        <span class="keyword">for</span>(Edge e = G.firstEdge(v); </span><br><span class="line">                G.isEdge(e); e = G.nextEdge(e))&#123;</span><br><span class="line">            <span class="comment">// 更新e的终点w的距离</span></span><br><span class="line">            <span class="keyword">int</span> w = e.get_v2();</span><br><span class="line">            <span class="keyword">double</span> P = D[v] + G.getEdgeWt(e);</span><br><span class="line">            <span class="comment">// 如果w经过v的路径更短，则更新w的距离</span></span><br><span class="line">            <span class="keyword">if</span>(P &lt; D[w])&#123;</span><br><span class="line">                D[w] = P;</span><br><span class="line">                <span class="comment">// 将w添加到队列中</span></span><br><span class="line">                Q.enqueue(<span class="keyword">new</span> ElemItem&lt;Integer&gt;(w));</span><br><span class="line">                <span class="comment">// 将w的父节点重置为v</span></span><br><span class="line">                V[w] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"●"</span>);</span><br><span class="line">        Q.printQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据V数组建立最短路径树SPT</span></span><br><span class="line">    mst.addChild(s, s, <span class="keyword">new</span> ElemItem&lt;Double&gt;(D[s]));</span><br><span class="line">    mst.setRoot(s);</span><br><span class="line">    <span class="keyword">int</span> f = -<span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 顶点标记数组，V_idx[i] == 1表示i顶点已经在SPT中，否则不再SPT中</span></span><br><span class="line">    <span class="keyword">int</span>[] V_idx = <span class="keyword">new</span> <span class="keyword">int</span>[V.length];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V_idx.length; i++)V_idx[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 起始顶点s已经在SPT中</span></span><br><span class="line">     V_idx[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        f = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 顶点i不在SPT中，其父顶点V[i]在SPT中，则添加到SPT中</span></span><br><span class="line">            <span class="keyword">if</span>(V_idx[i] == <span class="number">0</span> &amp;&amp; V[i] &gt;= <span class="number">0</span> &amp;&amp; V_idx[V[i]] == <span class="number">1</span> &amp;&amp; </span><br><span class="line">                mst.addChild(V[i], i, <span class="keyword">new</span> ElemItem&lt;Double&gt;(D[i])))&#123;</span><br><span class="line">                    V_idx[i] = <span class="number">1</span>;</span><br><span class="line">                    f = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次都没有添加，结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(f == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法实现过程中，用无穷大数Integer.MAX_VALUE分离队列中两遍处理的顶点，变量N记录操作了几遍，当N等于顶点个数时算法完成。算法最终广义树形式的SPT。</p>
<p>以图为示例，起始顶点为顶点4，根据算法过程，SPT创建过程如图(a~f)，图中记录每遍处理后各顶点的最短距离和队列中的顶点标号。</p>
<p><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-41-16.png"><br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-41-59.png"><br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-42-55.png"></p>
<p>可以简单地认为全源最短路径问题是单源最短路径问题的推广，即分别以每个顶点作为起始顶点，求其其余顶点到起始顶点的最短距离。例如，在有向非负权值图的中，将每个顶点作为起始顶点，利用Dijkstra算法求解其余顶点到起始顶点的最短距离，算法的时间开销为VElgV。</p>
<p>这里我们将讨论的两种算法针对更为一般的图，图中各条边的权值可以为负数。第一种算法为Floyd算法，针对稠密图，时间开销为V3；第二种算法为Johnson算法，针对稀疏图，该算法结合单源最短路径算法Bellman-Ford算法和Dijkstra算法，算法时间开销为VElogdV。两种算法求解的都是权值可以为负数（不包含负环）的有向带权图。</p>
<h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllPairsShortestPaths</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 待处理的图</span></span><br><span class="line">    GraphLnk G;</span><br><span class="line">    <span class="comment">// V[i][j]表示i在生成树中的父节点</span></span><br><span class="line">    EdgeElem P[][];</span><br><span class="line">    <span class="comment">// D[i]表示V[i]与i形成的边的权值</span></span><br><span class="line">    <span class="keyword">double</span> D[][];</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AllPairsShortestPaths</span><span class="params">(GraphLnk G)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.G = G;</span><br><span class="line">        <span class="comment">// 根据G的节点数创建数组</span></span><br><span class="line">        <span class="keyword">int</span> V = G.get_nv();</span><br><span class="line">        D = <span class="keyword">new</span> <span class="keyword">double</span>[V][V];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++)</span><br><span class="line">                D[i][j] = Double.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        P = <span class="keyword">new</span> EdgeElem[V][V];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++)</span><br><span class="line">                <span class="keyword">if</span>(G.isEdge(i, j))&#123;</span><br><span class="line">                    <span class="comment">// 将连接边添加到P数组中，更新D数组</span></span><br><span class="line">                    P[i][j] = <span class="keyword">new</span> EdgeElem(</span><br><span class="line">                            <span class="keyword">new</span> EdgeLnk(i, j, <span class="keyword">null</span>), </span><br><span class="line">                            G.getEdgeWt(i, j));</span><br><span class="line">                    D[i][j] = G.getEdgeWt(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// 数组D对角元设为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">            D[i][i] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">//  打印中间结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(D[i][j] != Double.MAX_VALUE)</span><br><span class="line">                    System.out.print(D[i][j] + <span class="string">"\t"</span>);</span><br><span class="line">                <span class="keyword">else</span> System.out.print(<span class="string">"∞\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Floyd 算法，求解全部最短路径算法 O(V^3);</span></span><br><span class="line"><span class="comment">     * 函数没有入参。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = G.get_nv();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(P[j][i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; V; t++)&#123;</span><br><span class="line">                        <span class="comment">// 更新顶点j到顶点t的距离，即D[j][t]</span></span><br><span class="line">                        <span class="keyword">if</span>(j != t &amp;&amp;</span><br><span class="line">                          D[j][t] &gt; D[j][i] + D[i][t])&#123;</span><br><span class="line">                            P[j][t] = P[j][i];</span><br><span class="line">                            D[j][t] = D[j][i] + D[i][t];</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">// 打印中间结果</span></span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; D.length; i2++)&#123;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; D.length; j2++)&#123;</span><br><span class="line">                                    <span class="keyword">if</span>(D[i2][j2] != Double.MAX_VALUE)</span><br><span class="line">                                        System.out.print(D[i2][j2] + <span class="string">"\t"</span>);</span><br><span class="line">                                    <span class="keyword">else</span> System.out.print(<span class="string">"∞\t"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                System.out.println();</span><br><span class="line">                            &#125;</span><br><span class="line">                            System.out.println(<span class="string">"\n------------------------"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法通过三重循环实现每对顶点之间的最短路径，如图，对顶点每个i，松弛每条边(j, t)，检查它的距离并确定是否存在更短的路径，并且边(j, i)为该路径中的边。算法实现过程中打印显示i变化过程中每对顶点之间的最短距离。</p>
<p>算法时间开销与V3成正比。算法中用二维数组D存放每对顶点之间的最短距离，例如，D[i][j]表示顶点i到顶点j之间的最短距离；数组P存放顶点顶点的路径，例如，P[i][j]表示顶点i到顶点j之间最短路径中的第一条表，按图索骥可以找到顶点i到j之间最短路径上的每条边。<br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-56-57.png"></p>
<h2 id="JohnSon算法"><a href="#JohnSon算法" class="headerlink" title="JohnSon算法"></a>JohnSon算法</h2><p>Johnson算法可以在O(VElgV)时间内求解每对顶点之间的最短路径。对于稀疏图，该算法在要好于Floyd算法。算法与Floyd算法类似，每对顶点之间的最短距离用二维数组D表示；如果图中存在负环，算法将输出警告信息。Johnson算法把Bellman-Ford算法和Dijkstra算法作为其子函数。</p>
<p>在本节一开始我们提到，如果以每个顶点作为起始顶点，用Dijkstra算法求解单源最短路径，则可以求解全源最短路径，算法复杂度为VElgV。但是对含有负权值的图，Dijkstra算法将失效。Johnson算法运用了“重赋权”技术，即将原图中每条边的权值ω重新赋值为ω’，并且具有以下两个性质：</p>
<p>l 对所有顶点对u,v，路径p是以权值为ω的原图的最短路径，当且仅当路径p也是以权值为ω’的图的最短路径；</p>
<p>l 对于所有的边(u, v)，ω’(u, v)是非负数。</p>
<p>重赋权后的图可以利用Dijkstra算法求解任意两个顶点之间的最短路径。稍后我们将会看到，重赋值不会改变最短路径，其处理复杂度为O(VE)。</p>
<p>下面我们将构造运算使得重赋权操作后得到的新的权值ω’满足上面提及的两个性质。</p>
<p>对带权有向图G=(V, E)，边(u, v)的权值ω(u, v)，设h为顶点映射到实数域的映射函数。对图中每条边(u, v)，定义：</p>
<p>ω’(u, v) = ω(u, v) + h(u) – h(v)</p>
<p>在这样的构造运算可以满足第一条性质，即如果路径p=&lt;v0, …, vk&gt;是权值ω条件下顶点v0到vk的最短路径，那么p也是新权值ω’条件下的最短路径。用lenω(p)表示路径p在原图中的长度，lenω’(p)表示路径p在重赋权后的图中的长度，则</p>
<p>lenω’(p) = ω’(v0, v1) +ω’(v1, v2) + … + ω’(vk-1, vk)</p>
<p>  = [ω(v0, v1) + h(v0) - h(v1)] + [ω(v1, v2) + h(v1) – h(v2)]+ … + [ω(vk-1, vk) + h(vk-1) – h(vk)]</p>
<p>  = ω(v0, v1) + ω(v1, v2) + … + ω(vk-1, vk) + h(v0) – h(vk)</p>
<p>  = lenω(p) + h(v0) – h(vk)</p>
<p>所以，如果权值为ω条件下顶点v0到vk存在一条更短的路径p<em>，那么对应地，在以权值为ω’的条件下，路径p</em>也比路径p更短。</p>
<p>再考虑第二条性质，即保证重赋权后权值非负。我们做如下的构造运算：</p>
<p>对给定的图G=(V, E)，，边(u, v)的权值ω(u, v)，构造一个新的图G’=(V’, E’)，其中一个新的顶点s∉V，V’=V∪{s}，E’=E∪{(s, u):u∈ V}，对所有的u∈V，ω(s, u)=0。G’中没有以顶点s为终点的边，所以，如果G中不存在负环，那么G’中也不会存在负环。</p>
<p>在不存在负环的前提下，定义h(u)=lenmin(s, u)，即顶点s到顶点u的最短路径，那么对所有的边(v, u)∈V’，h(u)≦ h(v) + ω(v, u)。那么在h(u)=lenmin(s, u)的条件下，便可满足ω’(u, v) = ω(u, v) + h(u) – h(v) ≧ 0，这样第二条性质便可满足。在上一节中我们讨论的Bellman-Ford算法能求解无负环的单元最短路径问题，可以用于求解h函数，其算法复杂度为O(VE)。</p>
<p>根据上面的讨论，Johnson算法结合Bellman-Ford算法和Dijkstra算法，包括以下几个步骤：</p>
<p>l 构造原图的扩展图G’=(V’, E’)，V’=V∪{s}，E’=E∪{(s, u):u∈ V}；</p>
<p>l 在G’中以s为起始顶点应用Bellman-Ford算法，求解各顶点到顶点s的最短路径；</p>
<p>l 对原图重赋权；</p>
<p>l 重赋权后以图中每个顶点为起始顶点，应用Dijkstra算法求解每对顶点之间的最短路径；</p>
<p>l 由于重赋权改变了图中路径的长度，最后需要还原上一步骤中求得最短路径的长度；</p>
<p>根据以上步骤，算法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JohnsonAlgo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> D[][];</span><br><span class="line">    <span class="keyword">int</span> P[][];</span><br><span class="line">    GraphLnk G;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JohnsonAlgo</span><span class="params">(GraphLnk G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.G = G;</span><br><span class="line">        D = <span class="keyword">new</span> <span class="keyword">double</span>[G.get_nv()][G.get_nv()];</span><br><span class="line">        P = <span class="keyword">new</span> <span class="keyword">int</span>[G.get_nv()][G.get_nv()];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Johnson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个图_G</span></span><br><span class="line">        GraphLnk _G = <span class="keyword">new</span> GraphLnk(G.get_nv() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.get_nv(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Edge e = G.firstEdge(i); </span><br><span class="line">                G.isEdge(e); e = G.nextEdge(e))</span><br><span class="line">                _G.setEdgeWt(e.get_v1(), e.get_v2(), G.getEdgeWt(e));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在原图的基础上添加一个顶点ad</span></span><br><span class="line">        <span class="keyword">int</span> ad = _G.get_nv() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.get_nv(); i++)&#123;</span><br><span class="line">            _G.setEdgeWt(ad, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 首先调用Bellman-Ford算法，以ad为起始点</span></span><br><span class="line">        MinusWeightGraph swg = <span class="keyword">new</span> MinusWeightGraph(_G);</span><br><span class="line">        swg.BellmanFord(ad);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// h函数</span></span><br><span class="line">        <span class="keyword">int</span> h[] = <span class="keyword">new</span> <span class="keyword">int</span>[G.get_nv() + <span class="number">1</span>];</span><br><span class="line">        System.out.println(<span class="string">"Bellman-Ford算法结果："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _G.get_nv(); i++)</span><br><span class="line">            System.out.print((h[i] = (<span class="keyword">int</span>)swg.D[i]) + <span class="string">"\t"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _G.get_nv() - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(Edge e = G.firstEdge(i); </span><br><span class="line">                G.isEdge(e); e = G.nextEdge(e))</span><br><span class="line">                <span class="comment">// 检测有没有负环</span></span><br><span class="line">                <span class="keyword">if</span>(h[e.get_v2()] &gt; h[e.get_v1()] + _G.getEdgeWt(e))</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"图中有负环。"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果没有则重赋权</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> u = G.edge_v1(e), v = G.edge_v2(e);</span><br><span class="line">                    <span class="keyword">int</span> wt = (<span class="keyword">int</span>) (G.getEdgeWt(e) + </span><br><span class="line">                            h[G.edge_v1(e)] - h[G.edge_v2(e)]);</span><br><span class="line">                    G.setEdgeWt(u, v, wt);</span><br><span class="line">                &#125;</span><br><span class="line">        System.out.println(<span class="string">"重赋权后的各条边的权值："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; G.get_nv(); u++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Edge e = G.firstEdge(u); </span><br><span class="line">                G.isEdge(e);</span><br><span class="line">                e = G.nextEdge(e))&#123;</span><br><span class="line">                System.out.print(u + <span class="string">"-"</span> + e.get_v2() + </span><br><span class="line">                        <span class="string">" "</span> + G.getEdgeWt(e) + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Dijkstra 算法求解每一个顶点的最短路径树</span></span><br><span class="line">        SingleSourceShortestPaths sssp = </span><br><span class="line">                        <span class="keyword">new</span> SingleSourceShortestPaths(G);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.get_nv(); i++)&#123;</span><br><span class="line">            sssp.Dijkstra(i);</span><br><span class="line">            System.out.println(<span class="string">"\n第"</span> + i + <span class="string">"顶点Dijkstra结果："</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.get_nv(); j++)&#123;</span><br><span class="line">                System.out.print(sssp.D[j] + <span class="string">"\t"</span>);</span><br><span class="line">                D[i][j] = sssp.D[j] + h[j] - h[i];</span><br><span class="line">                P[i][j] = sssp.V[j];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-58-50.png"><br>Bellman-Ford算法求解得到各个顶点的最短路径的长度对应这顶点的h函数的映射值，分别为：h(0)=0, h(1)=-67, h(2)=-16, h(3)=0, h(4)=-35, h(5)=-38, h(6)=0.</p>
<p>接下来根据各顶点的h函数值对原图G进行重赋权操作:</p>
<p>ω’(u, v) = ω(u, v) + h(u) – h(v)<br>过程为：</p>
<p>ω’(0, 1) = (41) + (0) - (-67) = 108</p>
<p>ω’(0, 5) = (29) + (0) - (-38) = 67</p>
<p>ω’(1, 2) = (51) + (-67) - (-16) = 0</p>
<p>ω’(1, 4) = (32) + (-67) - (-35) = 0</p>
<p>ω’(2, 3) = (50) + (-16) - (0) = 34</p>
<p>ω’(3, 0) = (45) + (0) - (0) = 45</p>
<p>ω’(3, 5) = (-38) + (0) - (-38) = 0</p>
<p>ω’(4, 2) = (32) + (-35) - (-16) = 13</p>
<p>ω’(4, 3) = (36) + (-35) - (0) = 1</p>
<p>ω’(5, 1) = (-29) + (-38) - (-67) = 0</p>
<p>ω’(5, 4) = (21) + (-38) - (-35) = 18</p>
<p>得到的图为：<br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-20-59-36.png"><br> 各个顶点调整：</p>
<p>D[0][0] = (0) - (0) + (0) = 0</p>
<p>D[0][1] = (67) - (0) + (-67) = 0</p>
<p>D[0][2] = (67) - (0) + (-16) = 51</p>
<p>D[0][3] = (68) - (0) + (0) = 68</p>
<p>D[0][4] = (67) - (0) + (-35) = 32</p>
<p>D[0][5] = (67) - (0) + (-38) = 29</p>
<p><img src= "/img/loading.gif" data-lazy-src="2020-09-23-21-00-54.png"></p>
<p>(e) 以顶点1为起始顶点，Dijkstra算法求得的在重赋权后的图的最短路径树。此时的最短路径对应着原图中的最短路径，但需要调整路径长度，各个顶点调整：</p>
<p>D[1][0] = (46) - (-67) + (0) = 113</p>
<p>D[1][1] = (0) - (-67) + (-67) = 0</p>
<p>D[1][2] = (0) - (-67) + (-16) = 51</p>
<p>D[1][3] = (1) - (-67) + (0) = 68</p>
<p>D[1][4] = (0) - (-67) + (-35) = 32</p>
<p>D[1][5] = (1) - (-67) + (-38) = 30</p>
<p> <img src= "/img/loading.gif" data-lazy-src="2020-09-23-21-01-15.png"></p>
<p>(f) 以顶点2为起始顶点，Dijkstra算法求得的在重赋权后的图的最短路径树。此时的最短路径对应着原图中的最短路径，但需要调整路径长度，各个顶点调整：</p>
<p>D[2][0] = (79) - (-16) + (0) = 95</p>
<p>D[2][1] = (34) - (-16) + (-67) = -17</p>
<p>D[2][2] = (0) - (-16) + (-16) = 0</p>
<p>D[2][3] = (34) - (-16) + (0) = 50</p>
<p>D[2][4] = (34) - (-16) + (-35) = 15</p>
<p>D[2][5] = (34) - (-16) + (-38) = 12</p>
<p><img src= "/img/loading.gif" data-lazy-src="2020-09-23-21-04-10.png"><br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-21-04-28.png"><br><img src= "/img/loading.gif" data-lazy-src="2020-09-23-21-04-41.png"></p>
<p>(i) 以顶点5为起始顶点，Dijkstra算法求得的在重赋权后的图的最短路径树。此时的最短路径对应着原图中的最短路径，但需要调整路径长度，各个顶点调整：</p>
<p>D[5][0] = (46) - (-38) + (0) = 84</p>
<p>D[5][1] = (0) - (-38) + (-67) = -29</p>
<p>D[5][2] = (0) - (-38) + (-16) = 22</p>
<p>D[5][3] = (1) - (-38) + (0) = 39</p>
<p>D[5][4] = (0) - (-38) + (-35) = 3</p>
<p>D[5][5] = (0) - (-38) + (-38) = 0</p>
<p><img src= "/img/loading.gif" data-lazy-src="2020-09-23-21-05-09.png"></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">sarsae</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/23/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/">http://yoursite.com/2020/09/23/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">SarsaeCola</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/23/%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">深度与广度优先搜索</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/23/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">拓扑排序</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/22/图论算法入门/" title="图论算法入门"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-22</div><div class="relatedPosts_title">图论算法入门</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/23/拓扑排序/" title="拓扑排序"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-23</div><div class="relatedPosts_title">拓扑排序</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/23/最小生成树/" title="最小生成树"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-23</div><div class="relatedPosts_title">最小生成树</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/23/深度与广度优先搜索/" title="深度与广度优先搜索"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-23</div><div class="relatedPosts_title">深度与广度优先搜索</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/23/无向图求割点和割边/" title="无向图求割点和割边"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-23</div><div class="relatedPosts_title">无向图求割点和割边</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/25/欧拉回路/" title="欧拉回路"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="relatedPosts_title">欧拉回路</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By sarsae</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>